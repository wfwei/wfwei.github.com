---
layout: post
title: "Git Learning"
categories: [tool, git]
---

##Git中存在unnamed branch

当你在unnamed branch上提交更改后，check到其他分支，如何找回刚才的更改?  
  1. 使用`git reglog`, 可以查看HEAD的指针的历史记录，从而查询到commit ID
  2. 使用`git checkout <commit-id>` 回到目标状态,之后使用`git checkout -b <new-branch-name>`给分支命名;如果想直接把这个分支merge到主分支，可以在master分支上执行:`git merge <commit-id>`
  

###Git BASIC

1. git模式:   git是C语言编写的分布式版本控制工具，之所以说git是分布式的，主要原因是，每个用户都有一份完整的版本库，包括版本库的各种历史信息以及标签分支等等。（因此，）用户总是在本地编辑版本库，并且提交到本地的版本库。当多人合作时，须要有一个大家都可以随时可以访问的版本库，Git称之为remote repository。这样，大家可以从这个remote版本库中下载（clone，pull）和提交（push）代码，以此协作开发。

2. 基本配置（git config）: Git会在你的用户根目录下生成一个全局配置文件:.gitconfig。这个文件存储了诸如git用户，邮箱以及git bash界面颜色显示的配置。

    一些基本命令：

    `git config --list ##显示所有git设置`
    `git config --global user.name "your name" ## 设置git用户`
    `git config --global user.email "your email" ## 设置git用户邮箱`
    `git config --global color.status auto`
    `git config --global color.branch auto`

    另外，git还可以设置忽略列表，因为有很多内容是没有必要同步到版本库中的，比如一些自自动生成的二进制文件等，我们可以在任意目录下添加一个**.gitignore**文件，其中记载改目录中哪些文件不需要同步到版本库，可以使用一些表达式，比如*.pyc。注意两点：

    1. .gitignore文件是有继承关系的，即：在上层目录上的.gitignore文件配置会对子目录有影响，同时子目录中也可添加.gitignore文件配置覆盖上级目录的配置。
    2. 修改.gitignore过滤某类文件后，Git不会在版本库中删除已有的文件，只是以后不会再更新过滤的文件

     
3. git的使用:在第一部分已经介绍了git的分布式模式，所以，在使用git的时候分两种情况：本地版本库操作和remote版本库操作。

    详细说一下git的组成，本地的git版本库实际包含两部分：
            
    1. **版本控制库**：是对git版本库的控制信息，包含版本库的各个历史版本（以某种压缩格式存储），各种操作信息，比如分支，某次提交的消息作者等记录
        
    2. **源码**（用户可以在源码上coding，之后提交到上面的版本控制库中）

    由此可以看出，在本地的git版本库中至少存在两分源码，一份是源码，用户直接可见可编辑的，另一份是压缩在版本控制库中。

    现在就可理解如何多人共同开发了，我们将版本控制库放到远端（服务器），之后多个人可以从上面下载当前最新代码，之后可以将自己更新的代码提交到这个远端的git版本控制库中，对于远端，在第6部分还有详细解释和操作。

    关于本地版本库的操作，首先新建一个版本库，也就是将一些文件放到版本库的控制之中。可以使用一下命令：
     
    1. git init   #初始化本地文档库，确切的说是生成版本控制库
    2. git add .   # 将该目录下的所有文件添加到文本库（索引）中
    3. git commit -m "Initial Commit"  # 提交到本地版本控制库，作为一条记录，-m “Initial Commit” 记录信息
    4. git log #查看提交的历史记录
    5. git diff #查看当前源码和版本控制库中最新代码之间的区别
    6. git status #查看当前文档库有哪些改变，包括增加的文件盒删除的文件
    7. git rm filename #将文件移除版本库（包括索引）  区别于直接用rm

    如何理解上面提到的索引：可以理解成版本控制库控制的文件的目录吧，有两种情况不在索引中，一是新建的文件还没有使用git add命令添加，二是.gitignore中包含的文件

4. 技巧：
    
    1. 关于git commit 参数问题
    
        `-m "添加记录信息"`
        `-a #会提交改变的文件，但是新增文件不会提交（若有新增文件须用 git add filename）`

    2. 一次执行多条命令
     
        `git add . && git commit -m " commit message"`

    3. 打开图形界面
     
        `gitk --all`

    4. 覆盖上次的提交

        `git commit --amend -m "update last commit"`


5. 注意点
    
    关于删除文件：直接用rm 而不是 git rm删除文件后，使用`git add . && git commit -m "del filename"`不会成功删除文件，需使用`git add -A . && git commit -m "del filename"`或者`git commit -a -m "del filename"`

    使用`git rm`后会将文件在索引也删除掉，就等于git已经知道删除这个文件了；而直接`rm`，文件还在git的索引中，只是从文件系统中删除了。。。
    
    这又会涉及到恢复问题，当文件被直接rm掉后，在commit之前，可以直接使用`git checkout filename`将文件恢复。若使用`git rm`删除的话，`git checkout filename`是找不到改文件的，因为已经不在git的索引中了，此时需要先`git revert head`这个操作是将索引信息恢复到上次commit，之后再checkout。。。这个过程同样适用于文件改动的恢复


6. 关于**remote**版本库的操作

    首先说一点，git的remote版本库和本地的版本库不同，本地版本库包含两部分，一个是源码，我们可以直接查看使用，一个是版本库文件，用来控制我们的代码。作为remote的版本库是用来给多个用户同步的，不需要源码，因此只保留版本库文件。

    1. 获取版本库，一般直接 git clone 版本库地址 ，这样就生成一个本地的版本库，如果不想要源码部分，即只想一个remote版本库副本，可以使用--bare参数。
    2. 在本地版本库中操作，如第一部分，之后将结果上传到remote版本库中。可以使用命令： git push remote版本库地址
    3. 一般开始工作前，最好先同步一下版本库，有一个简单的命令 git pull remote版本库地址 这个命令的功能是获取remote版本库的内容，并强制覆盖本地版本库。这个命令很危险，很可能是你的工作化为乌有，其实这个命令可以分解为两个：首先git fetch remote版本库地址,获取remote版本库的信息，之后git merge 就会将获取到得remote版本库合并到本地的版本库中，如果有冲突，会提示修改，最基本的方法就是手动修改有冲突的文件。


    技巧：remote版本库地址 一般都很长很难记，而且一个版本库一般就对应固定的remote版本库地址，所以，git可以对remote版本库地址起一个较短的名字，使用命令：git remote add shortname remote版本库地址 。  其中，shortname一般称为origin，当然也可以自定义。在add之前最好使用 git remote 命令查看当前版本库中已有的命名。重命名之后，就可以改写push操作为 git push origin


7. 参考：

    1，http://www.vogella.de/articles/Git/article.html
