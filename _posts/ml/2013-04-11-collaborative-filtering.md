---
layout: post
title: "协同过滤技术"
categories: [ml, collaborative filtering]
---
## 协同过滤基础

* 协同过滤的两种方式：基于邻域(neighborhood)；基于潜在语义(latent factor model)

* 使用基于用户的协同过滤进行预测用户喜好，给定下几组数据，来预测u1对i3的喜好
  
    #3个用户，3个电影，打分区间为1-5,以下是打分矩阵
    u1={4, 4, ?}
    u2={1，1, 1}
    u3={4, 1, 4}

  * 其中存在两个相似关系：相似打分趋势(如u1,u2),相似喜好(如u1,u3)
  * cosin比较的是用户的打分趋势，即u1和u2更相似，使用u2对u1中问号估分大概是2左右
  * 但这明显是不合理的，因为1,2表示不喜欢，3表示一般，4,5表示喜欢，按照趋势，u2不喜欢的，u1喜欢，应该给高分才对
  * 解决这个问题的方法是所有用户打分都减去各自的均值,这样值的正负表示喜好
  * 如果是使用item-based方法就不存在这个问题（i1和i3相似，估计4分左右，比较合理）

* 推荐和预测打分是两个十分不同的工作(以user-based为例)
  * 推荐是找到目标用户的相似邻居，在邻居中找到打分高且目标用户没打分的项目，进行推荐
  * 预测是给定了用户和项目，预测分值，方法是先找用户邻居，根据用户邻居对这个项目的打分进行预测
    * top k个邻居如果都没对目标项目打分，只能使用用户或项目的平均打分了
    * top k个邻居中如果有和目标用户相似度为负的用户，要不要处理以及怎么处理？
        * 这个问题试验表明，认为相似度为负的用户喜好相反不靠谱
* 从上面的分析发现，如果使用基于邻域的方法预测用户打分，最好使用下面模型：
  r=avg(u,i)+avg(u)+avg(i)+f(u,i)

## 增强协同过滤

##基本东西
* 线性插值
