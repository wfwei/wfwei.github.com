---
layout: post
title: "Java基础"
category: posts
---

* Java中没有排序的List，因为List本来就是有序了，如LinkedList是按照插入顺序排的，ArrayList固定了顺序，如果想改变顺序可以使用collections.sort(...)方法；如果有动态排序需求，可以使用优先队列PriorityQueue，如果要求容器大小固定，可以使用TreeSet来手动实现，如果还需要元素可以重复，可以考虑死用Guava包中的相关实现

* IO流同步问题 TODO
    * InputStream/OutputStream 抽象类，read，write方法都没同步
    * FileInputStream/FileOuputStream read/write等方法都是native的

* ArrayList序列化
    * ArrayList中存放数据的数组被声明为transient的，之后重写了序列化规则(writeObject(), readObject())


          public class ArrayList<E> extends AbstractList<E>
                  implements List<E>, RandomAccess, Cloneable, java.io.Serializable
          {
              private static final long serialVersionUID = 8683452581122892189L;

              /**
               * The array buffer into which the elements of the ArrayList are stored.
               * The capacity of the ArrayList is the length of this array buffer.
               */
              private transient Object[] elementData;

              ....

* StringBuffer扩容
    * 代码如下，很简洁，其他容器类扩容方式大体相同
    
            public AbstractStringBuilder append(String str) {
                if (str == null) str = "null";
                int len = str.length();
                ensureCapacityInternal(count + len);
                str.getChars(0, len, value, count);
                count += len;
                return this;
            }

            private void ensureCapacityInternal(int minimumCapacity) {
                // overflow-conscious code
                if (minimumCapacity - value.length > 0)
                    expandCapacity(minimumCapacity);
            }

            void expandCapacity(int minimumCapacity) {
                int newCapacity = value.length * 2 + 2;
                if (newCapacity - minimumCapacity < 0)
                    newCapacity = minimumCapacity;
                if (newCapacity < 0) {
                    if (minimumCapacity < 0) // overflow
                        throw new OutOfMemoryError();
                    newCapacity = Integer.MAX_VALUE;
                }
                value = Arrays.copyOf(value, newCapacity);
            }

* transient: The transient keyword in Java is used to indicate that a field should not be serialized.

* 判断中文字符

            private static final boolean isChinese(char c) {
            Character.UnicodeBlock ub = Character.UnicodeBlock.of(c);
            if (ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_COMPATIBILITY_IDEOGRAPHS
                || ub == Character.UnicodeBlock.CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A
                || ub == Character.UnicodeBlock.GENERAL_PUNCTUATION
                || ub == Character.UnicodeBlock.CJK_SYMBOLS_AND_PUNCTUATION
                || ub == Character.UnicodeBlock.HALFWIDTH_AND_FULLWIDTH_FORMS) {
              return true;
            }
            return false;
          }

          public static final boolean containChinese(String strName) {
            char[] ch = strName.toCharArray();
            for (int i = 0; i < ch.length; i++) {
              char c = ch[i];
              if (isChinese(c)) {
                return true;
              }
            }
            return false;
          }

* List.toArray() vs List.toArray(T[] arr)   java不能强制类型转化多个对象（数组），为什么？
* `Matcher.quoteReplacement(String replacement)`: 'literalize replacement', slash('/') or dollar('$') with no special meanings.   

      public static String updateCharsetValue(String file, Charset charset) {
          Matcher match = GenericCharsetPatt.matcher(file);
          StringBuffer nHtml = new StringBuffer();
          String pre, post;
          while (match.find()) {
            pre = match.group(1);
            post = match.group(3);
            match.appendReplacement(nHtml, Matcher.quoteReplacement(pre
                + charset.displayName() + post));
          }
          match.appendTail(nHtml);
          return nHtml.toString();
      }

* 有序字典(MAP)
    * Sort by keys, 使用SortedMap, 如TreeMap
    * Sort by values, 只能把map转化成list(`map.entrySet()`)，对list进行排序(`Collections.sort(...)`)，之后再插入到map(如LinkedHashMap,保持插入顺序)中

* eclipse中调用java的命令一般是：

      /usr/local/java/jre1.7.0_07/bin/java -Xmx1500m -Dfile.encoding=UTF-8 -classpath /media/Ubuntu/wksp/eclipse_wksp/BaiduReco/bin:/media/Ubuntu/wksp/eclipse_wksp/BaiduReco/lib/commons-collections-3.2.1.jar:/media/Ubuntu/wksp/eclipse_wksp/BaiduReco/lib/commons-configuration-1.7.jar:/media/Ubuntu/wksp/eclipse_wksp/BaiduReco/lib/log4j-1.2.16.jar baidu.zjl.train.ZjlTrain

* Java读写文件如果想设置编码，就要使用Stream相关的读写类
  * `new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
  * TODO

* java中参数传递都可以看成值传递，primivte的参数就不用说了，一般对象引用参数的传递，相当与传递了这个**引用的拷贝** [备忘](http://tjuking.iteye.com/blog/1405532)

      public class Swap {  
          public static void main(String[] args) {  
              ObjectSample o1 = new ObjectSample("hello");  
              ObjectSample o2 = new ObjectSample("ä½ å¥½");  
              System.out.println("before swap o1:"+o1.getTitle()+" o2:"+o2.getTitle());  
              Swap.swapObject(o1, o2);  
              System.out.println("after swap o1:"+o1.getTitle()+" o2:"+o2.getTitle());  
          }  
          static void swapObject(ObjectSample o1, ObjectSample o2){  
              ObjectSample temp = new ObjectSample("temp");  
              temp = o1;  
              o1 = o2;  
              o2 = temp;  
          }  
      }  
       
      class ObjectSample{  
          private String title;  
            
          ObjectSample(String title){  
              this.title = title;  
          }  
            
          public String getTitle(){  
              return title;  
          }  
      } 

* java.lang.Object
  1. 好多方法都是native的，即调用的虚拟机的底层语言，一般为c++
  2. clone方法是一个‘浅拷贝’，我的理解是对象中的所有域做了‘值拷贝’：
    1. 对象中的域分三种：primitive，不变对象(final的，如字符串)，普通对象
    2. 对于primitive进行‘值’拷贝是没有任何问题的
    3. 对于对象的‘值’拷贝，相当于只拷贝了引用，但指向的都是同一个实际对象
