---
layout: post
title: "jvm note2"
category: posts
---

##类加载机制
* 虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析以及初始化，最终形成可以被虚拟机直接运行的Java类型
* Java中类型加载和链接是在运行时完成，增加性能开销，但天生具有动态加载的语言特性，即运行时才知道具体的实现类
* 生命周期：
  * `加载--》验证--》准备--》解析--》初始化--》使用--》卸载`
  * 其中，解析阶段比较特殊，可以放到初始化后面！从而支持了动态绑定(运行时绑定)
* 类加载时机，**主动引用**，当且进当：
  * 实例化对象(new), 读取/设置类静态字段(**非常量**)(getstatic,putstatic),调用类的静态方法(invokestatic)
  * 反射调用类(java.lang.reflect)
  * 子类初始化引发父类初始化
  * 执行主类(main函数)
* 除上面四种主动引用外，其他的引用类方法都不会初始化类，称为**被动引用**
  * 子类引用父类静态字段，子类不会初始化
  * 定义类引用数组，不会出发类初始化（TODO 类对象引用大小固定的原因？）
    * 如定义：`MyClass[] a = new MyClass[]` 只会触发`[LMyClass`初始化(newarray引起)
    * `[LMyClass`直接继承Object，数组类型，这个类包含了访问数组的基本方法和变量，如`length``clone`，数组的访问都是通过该类，所以较C(++)更安全
  * static final的常量在编译阶段就存入***调用类***的常量池中，所以本质上没有直接引用到常量的***定义类***
* 接口的初始化类似与类，但是有所不同的是，子接口初始化不一定引起所有父接口初始化

##类加载过程
* “加载”，读取class文件，三件事:
  1. 通过类的全限定名获取定义此类的二进制字节流(可以有各种来源:压缩包,网络,运行时生成(反射),由其他文件生成(jsp))
  2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
  3. 在Java堆中生成一个代表这个类的`java.lang.Class`对象，作为方法区数据的入口
* 
