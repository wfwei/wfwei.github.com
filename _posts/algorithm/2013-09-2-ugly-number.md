---
layout: post
title: "丑数UglyNumber"
categories:  [programming, algorithm]
---

丑数：因子中只包含`2``3``5`的数，习惯上将`1`作为第一个丑数

求从小到大排序的第1500个数字

思路1：从小到大，依次判断每个数是不是丑数

上面思路简单，但需要对第1500个丑数前所有的数字进行判定

一种降低时间复杂度的方法是只寻找丑数

设三种运算分别是`×2`,`×3`,`×5`,那么这三种运算对于丑数集合来说是‘闭包’运算，如果不明白闭包，可以稍微看一下[这里](http://blog.codinglabs.org/articles/closure-perspective-of-abstract-mathematic-and-functional-language.html)

不难想象，所有的丑数都可以通过这三种运算求得，而且这三种运算是闭包操作，所以对于一个丑数通过这三种运算生成的数也一定都是丑数，这样就可以避免了上面提到的冗余计算

由于我们要计算从小到大排序的第n个数字，还需要搞定下面这个问题：给定前k个丑数(U1,U2,U3,...,Uk)，计算第k+1个丑数Uk+1

第k+1个丑数肯定是前面k个丑数中的某个数乘以`2,3,5`的一个结果，在前k个丑数中，分别找到最小的丑数`p2,p3,p5`，使得`p2*2>k``p3*3>k``p5*5>k`，之后`Uk+1=min(p2*2, p3*3, p5*5)`

这样初始状态k=1,即只有`1`这一个丑数，`p2=p3=p5=1`，显然`U2=min(p2*2, p3*3, p5*5)=min(2,3,5)=2`，将p2指向下一个丑数，这里就是刚求得的2，之后就不断按照上面方法求解下一个丑数，直到第N个

TODO code
