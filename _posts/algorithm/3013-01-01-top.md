---
layout: post
title: "置顶笔记"
categories: [algorithm, sort]
---

算法

### 不要为了提高一点效率而复杂化思路

尤其不要为了简化几个判断，把思路搞复杂

在没有‘数量级’效率问题时，因该注重程序的可理解性

### 不要为了简化代码而复杂了思路

简化代码是程序正确后该做的事情

### 尽量不要拷贝代码

相似流程的代码总是习惯拷贝，之后修改其中的变量，这很容易出错

其实再写一遍好处很多，一方面加深了思考，同时做了代码review



## 典型案例

###Leetcode#71 

>Given an absolute path for a file (Unix-style), simplify it.  
>For example,  
>path = "/home/", => "/home"  
>path = "/a/./b/../../c/", => "/c"


    public String simplifyPath(String path) {
        // Start typing your Java solution below
        // DO NOT write main() function
        if(path==null)
            return null;
        String[] names = path.split("/");
        // 这里使用栈这种结构在好不过了，当初为什么还想直接使用StringBuilder？？
        // 改用数据结构就要用，不要数据结构用的少才好，只要能够帮助正确编写程序，增加程序可读性，就要大胆用
        Stack<String> st = new Stack<String>();
        for(String name:names){
            if(name.length()>0 && !name.equals(".")){
                if(name.equals("..")){
                    if(!st.isEmpty())
                        st.pop();
                }else{
                    st.push(name);
                }
            }
        }
        // 幸好这里直接用StringBuilder了，没有想到用字符串简单拼接==！
        StringBuilder res = new StringBuilder();
        // 开始就没有注意到要‘顺序’遍历栈，为什么没想到！！！
        // 太粗心了，如果那个例子，画个图还会出错么？？！！
        for(int i=0; i<st.size(); i++){
            res.append("/").append(st.get(i));
        }

        //考虑输出为空的情况
        if(res.length()==0)
            res.append("/");
        return res.toString();
    }
