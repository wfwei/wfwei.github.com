---
layout: post
title: "Hashing"
categories: posts 
---

##哈希（散列）


##Perfect hashing
完美哈希,没有冲突的哈希函数.也就是，函数 H 将 N 个 KEY 值映射到 M 个整数上，这里 M>=N ，而且，对于任意的 KEY1 ，KEY2 ，H( KEY1 ) != H( KEY2 ) ，并且，如果 M = = N ，则 H 是最小完美哈希函数（Minimal Perfect Hash Function，简称MPHF)  
完美哈希是针对**静态集合**的，即所有的key都是事先已知且固定的。  
完美哈希有多种代码生成器，根据key集合自动生成哈希函数，如[gperf](http://www.gnu.org/software/gperf/)

## Solve Conflicts
Open  addressing和Chaining是两种不同的解决hash冲突的策略。当多个不同的key被映射到相同的slot时，chaining方式采用链表保存所有的value。而Open addressing则尝试在该slot的邻近位置查找，直到找到对应的value或者空闲的slot， 这个过程被称作probing。常见的probing策略有Linear probing，Quadratic probing和Double hashing。

## Locality-Sensitive Hashing(LSH)
    
**核心思想**:   
将相似输入（key）以高概率散列到同一个桶（bucket）中

**应用**  

1. probabilistic dimension reduction of high-dimensional data(降维)
2. ‘近似’最近邻算法 
	
**几种实现**    

1. Bit sampling for Hamming distance
2. *Min-wise independent permutations*
3. *Random projection*
4. Stable distributions

**min-wise independent permutations**
[TODO](http://en.wikipedia.org/wiki/MinHash)
		
**Random Projection(随机映射)**  
随机映射的相似性哈希算法比较的是两个向量的余弦距离。基本思想是随机构造k个平面(hyperplane)，每个平面都有其法向量表示，k个平面将整个空间且分为f(k)个子空间。
		
1. 选取k个hyperplane，构成2^k个bucket
2. 每个hyperplane都从高斯分布（比如N(0,1)）中random出一个向量u
3. 对于每个document，提取feature，构成一个向量v
4. 计算h(v)=v*u,通过sgn(h(v))的符号判断v在u所代表平面的哪一侧。按照这样的策略，两个document x,y被分到同一侧（认为collision）的概率是：`p= Pr(h(x)=h(y)) = 1-theta(x,y)/PI ---- theta(x,y) is the angle between x and y`
5. 每个document都在k个平面上利用4中方法计算，形成一次映射projection. 一次映射后，x,y被映射到同一个bucket的概率是p’=p^k，指数速度变小了
6. 一次映射后，p’是很小的，这很可能把locality-sensitive的点分到不同的bucket中
7. 可以做L次映射，只要在一次映射中最近邻被分到同一个bucket就可以了
8. 在给定平面数目k和最近邻被分到不同bucket的期望概率w的情况下，可以得到：`(1-p’)^L = w`
	    
**注意点：**  

1. k的大小影响到粒度，需要实际调节
2. 1-theta(x,y)/PI 和 cos(x,y) 的关系使得本方法中，locality-sensitive中的距离是指两个vector的cosin
3. w的大小影响到hash的效果，需实际调节

**参考:**

* [LSH@wikipedia](http://en.wikipedia.org/wiki/Locality-sensitive_hashing)
* [locality sensitive hashing for finding nearest neighbors](https://scholar.google.com)
* [Streaming First Story Detection with application to Twitter](https://scholar.google.com)

