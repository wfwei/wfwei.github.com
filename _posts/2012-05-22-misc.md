---
layout: post
title: "Misc"
---

##海明码
1. 具有自动纠错功能的校验方法
2. 在k个数据位之外加上r个校验位(奇偶校验)，从而形成一个k+r位的新码字，要求 2^r >= k+r+1 (k+r种出错位置以及1种没有出错的情况)
3. 校验位的分布，使用 2^0 , 2^1 , 2^2 ... 作为校验位（码距被指数型拉大）
4. 每一位i都能由和为i的校验位表示，比如第三位由前两位表示( 3 = 2^0 + 2^1 )
5. 

##k-d tree
* k-d tree是k dimension tree的缩写，是对数据点在k维空间中划分的一种数据结构。
* 给定一个点集，建树过程如下

    function kdtree (list of points pointList, int depth)
    {
        // Select axis based on depth so that axis cycles through all valid values
        var int axis := depth mod k;
            
        // Sort point list and choose median as pivot element
        select median by axis from pointList;
            
        // Create node and construct subtrees
        var tree_node node;
        node.location := median;
        node.leftChild := kdtree(points in pointList before median, depth+1);
        node.rightChild := kdtree(points in pointList after median, depth+1);
        return node;
    }

* 第depth层是通过比较`depth/k`维的值进行划分的
* 当维数较大时，直接利用k-d树快速检索的性能急剧下降。假设数据集的维数为D，一般来说要求数据的规模N满足条件：N远大于2的D次方，才能达到高效的搜索。
* 感觉kdtree中只能应用于求欧式距离的最近邻?
* [wiki-ref](http://en.wikipedia.org/wiki/K-d_tree), [csdn-ref](http://blog.csdn.net/qll125596718/article/details/8426458),[csdn-ref2](http://blog.csdn.net/v_july_v/article/details/8203674)

##MediaWiki搭建
[mediawiki](http://www.mediawiki.org/wiki/MediaWiki)的安装和配置方式实在是与众不同，完全在线安装和配置，这个真心不习惯，感觉Mediawiki这种'创新'真是费力不讨好。  
搭建这个wiki已经然我抓狂了，真心要抓狂了，就是因为始终配置不好WYSIWYG这个插件，尼玛，现在也没配置好，不过换了另外一个富文本编辑器[WikEdi](http://en.wikipedia.org/wiki/User:Cacycle/wikEd)，几分钟搞定，如果也有人在纠结Mediawiki的WYSIWYG插件不显示的问题，还是奉劝一句，使用WikEd吧，虽然没WYSIWYG好用，但是WYSIWYG插件不显示的问题很难搞定，尤其是当你不熟悉php的时候，貌似这个bug很普遍，谷歌到一大片。。。  


##编程中Charset和Encoding的区别

* 两个概念：Charset 和 Character Encoding

    * Charset 字符集，如ascii, gb2312, unicode...
    * Character Encoding 编码方式，即如何将二进制流转化解析为字符，如utf8就是一种对unicode的编码方式，特点是变长编码

* Charset的发展：

    1. 最开始是ascii码（american standard code of information interchange 美国标准信息交换码），由7bits组成，再加上1个校验位，组成一个byte字节，共可以表示128个字符，当时已经够用了
    2. 当计算机国际化时，各国语言都要编码，这时候ascii不够用了，由此出现了 MBCS ( Multi-Byte Character System，多字节字符系统)，各国都建立自己的字符集，如中国的gb编码，日本的gis编码，中国台湾的big5编码等等
    3. 各国各自为政的编码体系严重阻碍国际化，由此有个叫 Unicode Consortium 的机构，决定做一个囊括所有字符在内的字符集(UCS, Universal Character Set)和对应编码方式的标准，即 Unicode
    4. UCS是一个字符集，其编码方式分为两种：等长编码和变长编码。由于UCS很大，等长编码使得单个字符编码较长，不适合存储和传输，而变长编码就很好的解决了这个问题（结合哈夫曼编码）。其中最为著名应用也最广的就是utf-8编码。
    5. UTF-8 (UCS Transformation Format — 8-bit[1]) is a variable-width encoding that can represent every character in the Unicode character set. 

##UTF-8编码介绍

to be implemented...

##Berkeley DB

* 参考：
  * http://www.ibm.com/developerworks/cn/linux/l-embdb/index.html
  * http://hi.baidu.com/shirdrn/blog/item/28e1573948cffdf43b87ce6e.html

* 摘要
  1. BDB是嵌入式数据库：嵌入式数据库是指运行在本机上、不用启动服务端的轻型数据库，它与应用程序紧密集成，被应用程序所启动，并伴随应用程序的退出而终止。目前，嵌入式数据库市场主要由三个产品分割：SQLite，Birkeley DB，Firebird嵌入服务器版，巧的是，这三个数据库产品都是开源软件。
  2. DB提供了一系列应用程序接口（API），调用本身很简单，应用程序和DB所提供的库在一起编译成为可执行程序。这种方式从两方面极大提高了DB的效率。第一：DB库和应用程序运行在同一个地址空间，没有客户端程序和数据库服务器之间昂贵的网络通讯开销，也没有本地主机进程之间的通讯；第二：不需要对SQL代码解码，对数据的访问直截了当。
  3. DB对需要管理的数据看法很简单，DB数据库包含若干条记录，每一个记录由关键字和数据（KEY/VALUE）构成。数据可以是简单的数据类型，也可以是复杂的数据类型。
  4.
对DB的访问算法的选择，首先要看关键字的类型，如果为复杂类型，则只能选择B+树或HASH算法，如果关键字为逻辑记录号，则应该选择Recno或Queue算法。当工作集关键字有序时，B+树算法比较合适；如果工作集比较大且基本上关键字为随机分布时，选择HASH算法。Queue算法只能存储定长的记录，在高的并发处理情况下，Queue算法效率较高；如果是其它情况，则选择Recno算法，Recno算法把数据存储为平面文件格式。

##32位 win7 集成显卡 --> 4g内存 3.16g可用
* 参考
  * [32位系统4G内存到底能否完全使用的问题](http://www.2cto.com/os/201205/132001.html)
* 个人摘要
  1. 32位os（32条地址线），最大编址4G大小的逻辑地址空间
  2. 需要编址的的设备：主板BIOS的ROM，（集成）显卡上的显存RAM，各种PCI(-E)设备上的RAM和ROM，以及最熟悉的内存RAM
  3. 系统不仅要给主板上的内存条编址，还要给上述的其它物理内存编址；它们都被编在同一个地址空间内，编址后的物理内存就可以被系统资源使用或占用。
  4. 地址空间可以分为两大部分：高位地址分配给BIOS（ROM）和PCI(-E)设备的存储器d等，由于这些存储器基本上是用于系统输入输出，所以Intel将这段地址空间称为MMIO(Memory-Mapped I/O—I/O存储器映射)；剩余的地址才分配给内存RAM。
  5. 当系统安装3GB以下的内存时，MMIO区域不会和物理内存条的地址空间相重叠，操作系统可以访问几乎全部的物理内存。 

##2012年4月1日
* 参考
  * 使用[google goagent](http://code.google.com/p/goagent/)
* 摘要
  1. 申请Google Appengine并创建appid。
  2. 下载goagent稳定版 http://code.google.com/p/goagent/ (下载文件有两个文件夹，分别是：server和local)
  3. 修改local\proxy.ini中的[gae]下的appid=你的appid(多appid请用|隔开)
  4. 在server目录下运行`python uploader.zip`，如果要上传python服务端的话，在server目录下运行`uploaddir=python python uploader.zip`或者尝试GoAgentX
  5. chrome请安装SwitchySharp插件，然后导入这个设置http://goagent.googlecode.com/files/SwitchyOptions.bak
  * 在执行第4步的时候，出现一个error32，搜了一下相关解决方案：先执行`export https_proxy=127.0.0.1:8087`，之后在`python uploader.zip`，OK了
  * 如果第5步不熟悉，先到google的webstore上下载安装switchysharp，之后在设置里面导入刚下在的bak备份文件。
