---
layout: post
title: "Misc"
category: other
---

### 进程，线程
1. 一个程序至少一个进程，一个进程至少一个线程
2. 进程是操作系统进行资源分配，以及独立运行的基本单位，在采用微内核的操作系统中，以线程作为调度单位
3. 线程是进程的一个实体，是CPU调度的基本单位，但其没有独立的地址空间，只有自己独立的局部变量和堆栈？？
4. 线程不需协作同步，但是进程间需要消息通信机制同步
5. 进程由于独立拥有系统资源，建立和撤销的开销都较大；进程是不活泼的，从来不执行任何操作，只是线程的容器；由两部分组成
    1. 内核对象，OS用来管理进程，存放进程的统计信息
    2. 地址空间，包含所有可执行模块的代码和数据，以及动态内存所分配的空间，如堆栈
6. 线程分两部分：
    1. 内核对象，OS用来管理线程，存放线程统计信息
    2. 线程堆栈，线程运行时需要的参数和局部变量等
7. 线程同步策略：
    1. 临界区
    2. 事件，互斥量，信号量等
6. 进程通信方式：
    1. 管道  
    匿名管道用户具有亲缘关系的进程见通信，有名管道打破此限制
    2. 消息队列
    对消息队列有写权限的进程可以向管道中添加消息；具有读权限的进程从管道中读取消息
    3. 共享内存
    多个进程可以访问同一块内存区，不同进程可以及时看到对方进程中对共享内存的数据更新，这种方式叫常见，需要互斥锁或信号量
    4. 信号量
    5. 套接字
    网络计算机通信方式

### 海明码
1. 具有自动纠错功能的校验方法
2. 在k个数据位之外加上r个校验位(奇偶校验)，从而形成一个k+r位的新码字，要求 2^r >= k+r+1 (k+r种出错位置以及1种没有出错的情况)
3. 校验位的分布，使用 2^0 , 2^1 , 2^2 ... 作为校验位（码距被指数型拉大）
4. 每一位i都能由和为i的校验位表示，比如第三位由前两位表示( 3 = 2^0 + 2^1 )
5. 

### k-d tree
* k-d tree是k dimension tree的缩写，是对数据点在k维空间中划分的一种数据结构。
* 给定一个点集，建树过程如下

    function kdtree (list of points pointList, int depth)
    {
        // Select axis based on depth so that axis cycles through all valid values
        var int axis := depth mod k;
            
        // Sort point list and choose median as pivot element
        select median by axis from pointList;
            
        // Create node and construct subtrees
        var tree_node node;
        node.location := median;
        node.leftChild := kdtree(points in pointList before median, depth+1);
        node.rightChild := kdtree(points in pointList after median, depth+1);
        return node;
    }

* 第depth层是通过比较`depth/k`维的值进行划分的
* 当维数较大时，直接利用k-d树快速检索的性能急剧下降。假设数据集的维数为D，一般来说要求数据的规模N满足条件：N远大于2的D次方，才能达到高效的搜索。
* 感觉kdtree中只能应用于求欧式距离的最近邻?
* [wiki-ref](http://en.wikipedia.org/wiki/K-d_tree), [csdn-ref](http://blog.csdn.net/qll125596718/article/details/8426458),[csdn-ref2](http://blog.csdn.net/v_july_v/article/details/8203674)

### MediaWiki搭建
[mediawiki](http://www.mediawiki.org/wiki/MediaWiki)的安装和配置方式实在是与众不同，完全在线安装和配置，这个真心不习惯，感觉Mediawiki这种'创新'真是费力不讨好。  
搭建这个wiki已经然我抓狂了，真心要抓狂了，就是因为始终配置不好WYSIWYG这个插件，尼玛，现在也没配置好，不过换了另外一个富文本编辑器[WikEdi](http://en.wikipedia.org/wiki/User:Cacycle/wikEd)，几分钟搞定，如果也有人在纠结Mediawiki的WYSIWYG插件不显示的问题，还是奉劝一句，使用WikEd吧，虽然没WYSIWYG好用，但是WYSIWYG插件不显示的问题很难搞定，尤其是当你不熟悉php的时候，貌似这个bug很普遍，谷歌到一大片。。。  


### 编程中Charset和Encoding的区别

* 两个概念：Charset 和 Character Encoding

    * Charset 字符集，如ascii, gb2312, unicode...
    * Character Encoding 编码方式，即如何将二进制流转化解析为字符，如utf8就是一种对unicode的编码方式，特点是变长编码

* Charset的发展：

    1. 最开始是ascii码（american standard code of information interchange 美国标准信息交换码），由7bits组成，再加上1个校验位，组成一个byte字节，共可以表示128个字符，当时已经够用了
    2. 当计算机国际化时，各国语言都要编码，这时候ascii不够用了，由此出现了 MBCS ( Multi-Byte Character System，多字节字符系统)，各国都建立自己的字符集，如中国的gb编码，日本的gis编码，中国台湾的big5编码等等
    3. 各国各自为政的编码体系严重阻碍国际化，由此有个叫 Unicode Consortium 的机构，决定做一个囊括所有字符在内的字符集(UCS, Universal Character Set)和对应编码方式的标准，即 Unicode
    4. UCS是一个字符集，其编码方式分为两种：等长编码和变长编码。由于UCS很大，等长编码使得单个字符编码较长，不适合存储和传输，而变长编码就很好的解决了这个问题（结合哈夫曼编码）。其中最为著名应用也最广的就是utf-8编码。
    5. UTF-8 (UCS Transformation Format — 8-bit[1]) is a variable-width encoding that can represent every character in the Unicode character set. 

### Berkeley DB

* 参考：
  * http://docs.oracle.com/cd/E17277_02/html/GettingStartedGuide/applicationoverview.html
  * http://www.aosabook.org/en/bdb.html  (http://www.ituring.com.cn/article/8111)
  * http://www.ibm.com/developerworks/cn/linux/l-embdb/index.html
  * http://hi.baidu.com/shirdrn/blog/item/28e1573948cffdf43b87ce6e.html

* 摘要
  1. BDB是嵌入式数据库：嵌入式数据库是指运行在本机上、不用启动服务端的轻型数据库，它与应用程序紧密集成，被应用程序所启动，并伴随应用程序的退出而终止。目前，嵌入式数据库市场主要由三个产品分割：SQLite，Birkeley DB，Firebird嵌入服务器版，巧的是，这三个数据库产品都是开源软件。
  2. DB提供了一系列应用程序接口（API），调用本身很简单，应用程序和DB所提供的库在一起编译成为可执行程序。这种方式从两方面极大提高了DB的效率。第一：DB库和应用程序运行在同一个地址空间，没有客户端程序和数据库服务器之间昂贵的网络通讯开销，也没有本地主机进程之间的通讯；第二：不需要对SQL代码解码，对数据的访问直截了当。
  3. DB对需要管理的数据看法很简单，DB数据库包含若干条记录，每一个记录由关键字和数据（KEY/VALUE）构成。数据可以是简单的数据类型，也可以是复杂的数据类型。
  4.
对DB的访问算法的选择，首先要看关键字的类型，如果为复杂类型，则只能选择B+树或HASH算法，如果关键字为逻辑记录号，则应该选择Recno或Queue算法。当工作集关键字有序时，B+树算法比较合适；如果工作集比较大且基本上关键字为随机分布时，选择HASH算法。Queue算法只能存储定长的记录，在高的并发处理情况下，Queue算法效率较高；如果是其它情况，则选择Recno算法，Recno算法把数据存储为平面文件格式。
  5. Berkeley DB为何高效？
      * 应用程序和数据库管理系统运行在相同的进程空间当中，进行数据操作时可以避免繁琐的进程间通信包括建立socket连接等
      * 使用简单的函数调用接口来完成所有的数据库操作，而不是在数据库系统中经常用到的SQL语言,避免了对结构化查询语言进行解析和处理所需的开销
  6. 关键字/数据 是Berkeley DB用来进行数据库管理的基础。每个 Key/Data 对构成一条记录。
  7. 

### 32位 win7 集成显卡 --> 4g内存 3.16g可用
* 参考
  * [32位系统4G内存到底能否完全使用的问题](http://www.2cto.com/os/201205/132001.html)
* 个人摘要
  1. 32位os（32条地址线），最大编址4G大小的逻辑地址空间
  2. 需要编址的的设备：主板BIOS的ROM，（集成）显卡上的显存RAM，各种PCI(-E)设备上的RAM和ROM，以及最熟悉的内存RAM
  3. 系统不仅要给主板上的内存条编址，还要给上述的其它物理内存编址；它们都被编在同一个地址空间内，编址后的物理内存就可以被系统资源使用或占用。
  4. 地址空间可以分为两大部分：高位地址分配给BIOS（ROM）和PCI(-E)设备的存储器d等，由于这些存储器基本上是用于系统输入输出，所以Intel将这段地址空间称为MMIO(Memory-Mapped I/O—I/O存储器映射)；剩余的地址才分配给内存RAM。
  5. 当系统安装3GB以下的内存时，MMIO区域不会和物理内存条的地址空间相重叠，操作系统可以访问几乎全部的物理内存。 

### GoAgent使用
* 参考
  * [google goagent](http://code.google.com/p/goagent/)
* 摘要
  1. 申请Google Appengine并创建appid。
  2. 下载goagent稳定版 http://code.google.com/p/goagent/ (下载文件有两个文件夹，分别是：server和local)
  3. 修改local\proxy.ini中的[gae]下的appid=你的appid(多appid请用|隔开)
  4. 在server目录下运行`python uploader.zip`，如果要上传python服务端的话，在server目录下运行`uploaddir=python python uploader.zip`或者尝试GoAgentX
  5. chrome请安装SwitchySharp插件，然后导入这个设置http://goagent.googlecode.com/files/SwitchyOptions.bak
  * 在执行第4步的时候，出现一个error32，搜了一下相关解决方案：先执行`export https_proxy=127.0.0.1:8087`，之后在`python uploader.zip`，OK了
  * 如果第5步不熟悉，先到google的webstore上下载安装switchysharp，之后在设置里面导入刚下在的bak备份文件。
